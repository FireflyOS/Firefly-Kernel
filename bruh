3d2
< #include <limine.h>
6,11c5,16
< #include "algorithm.hpp"
< #include "math.hpp"
< #include "memory.hpp"
< #include "page.hpp"
< #include "trace.hpp"
< #include "utility.hpp"
---
> #include <algorithm>
> 
> #include "cstdlib/cmath.h"
> #include "firefly/stivale2.hpp"
> #include "libk++/memory.hpp"
> #include <utility>
> 
> #include "cstdlib/cassert.h"
> #include "firefly/logger.hpp"
> #include "firefly/memory-manager/page.hpp"
> #include "libk++/align.h"
> 
14c19
<   private:
---
> private:
18,20c23,25
<   public:
<     AddressType ptr{nullptr};
<     Order order{0};
---
> public:
>     AddressType ptr{ nullptr };
>     Order order{ 0 };
23c28
<   public:
---
> public:
25,26c30,35
<     BuddyAllocationResult(const AddressType &block, Order ord, int num_pages) : ptr(block), order(ord), npages(num_pages) {}
<     INLINE AddressType unpack() const { return ptr; }
---
>     BuddyAllocationResult(const AddressType &block, Order ord, int num_pages)
>         : ptr(block), order(ord), npages(num_pages) {
>     }
>     inline AddressType unpack() const {
>         return ptr;
>     }
29,31c38,39
< class BuddyAllocator
< {
<   public:
---
> class BuddyAllocator {
> public:
34,37d41
<     enum FillMode : int {
<         ZERO,
<         NONE
<     };
39,43c43,47
<     Order max_order = 0;                               // Represents the largest allocation and is determined at runtime.
<     constexpr static Order min_order = 9;              // 4kib, this is the smallest allocation size and will never change.
<     constexpr static Order largest_allowed_order = 30; // 1GiB is the largest allocation an instance of this class may serve.
<     constexpr static bool verbose{}, sanity_checks{};  // sanity_checks ensures we don't go out-of-bounds on the freelist.
<                                                        // Beware: These options will impact the performance of the allocator.
---
>     Order max_order = 0;                                // Represents the largest allocation and is determined at runtime.
>     constexpr static Order min_order = 9;               // 4kib, this is the smallest allocation size and will never change.
>     constexpr static Order largest_allowed_order = 30;  // 1GiB is the largest allocation an instance of this class may serve.
>     constexpr static bool verbose{}, sanity_checks{};   // sanity_checks ensures we don't go out-of-bounds on the freelist.
>                                                         // Beware: These options will impact the performance of the allocator.
45,46c49
<     void init(AddressType base, int target_order)
<     {
---
>     void init(AddressType base, int target_order) {
51c54
<             trace(TRACE_BUDDY, "min-order: %ld, max-order: %ld", min_order, max_order);
---
>             firefly::kernel::info_logger << firefly::kernel::info_logger.format("min-order: %d, max-order: %d", min_order, max_order);
53c56
< 		freelist.init();
---
>         freelist.init();
57,64c60,64
<     auto alloc(uint64_t size, FillMode fill = FillMode::ZERO)
<     {
<         Order order = max(min_order, log2(size >> 3));
< 
<         if constexpr (sanity_checks)
<         {
<             if (order > max_order)
<             {
---
>     auto alloc(uint64_t size, FillMode fill = FillMode::ZERO) {
>         Order order = std::max(min_order, log2(size >> 3));
> 
>         if constexpr (sanity_checks) {
>             if (order > max_order) {
66c66
<                     trace(TRACE_ERROR, "Requested order %d (%ld) is too large for this buddy instance | max-order is: %d", order, size, max_order);
---
>                     firefly::kernel::info_logger << firefly::kernel::info_logger.format("Requested order %d (%d) is too large for this buddy instance | max-order is: %d", order, size, max_order);
73c73
<             trace(TRACE_BUDDY, "Suitable order for allocation of size '%ld' is: %d", size, order);
---
>             firefly::kernel::info_logger << firefly::kernel::info_logger.format("Suitable order for allocation of size '%d' is: %d", size, order);
78,79c78
<         for (; ord <= max_order; ord++)
<         {
---
>         for (; ord <= max_order; ord++) {
85,86c84
<         if (block == nullptr)
<         {
---
>         if (block == nullptr) {
88c86
<                 trace(TRACE_BUDDY, "Block is a nullptr (order: %d, size: %ld)", order, size);
---
>                 firefly::kernel::info_logger << firefly::kernel::info_logger.format("Block is a nullptr (order: %d, size: %d)", order, size);
94,95c92
<         while (ord-- > order)
<         {
---
>         while (ord-- > order) {
107c104
<             trace(TRACE_BUDDY, "Allocated 0x%lx at order %d (max: %ld | min: %ld) with a size of %ld", block, ord, max_order, min_order, size);
---
>             firefly::kernel::info_logger << firefly::kernel::info_logger.format("Allocated 0xlx at order %d (max: %d | min: %d) with a size of %d", block, ord, max_order, min_order, size);
109c106
<         return BuddyAllocationResult(block, ord + 1, correct_size / 4096);
---
>         return BuddyAllocationResult(block, ord + 1, correct_size / PAGE_SIZE);
112,113c109
<     void free(AddressType block, Order order)
<     {
---
>     void free(AddressType block, Order order) {
119,120c115
<         if (order == max_order)
<         {
---
>         if (order == max_order) {
128,129c123
<     int log2(int size)
<     {
---
>     int log2(int size) {
131,132c125
<         while ((1 << result) < size)
<         {
---
>         while ((1 << result) < size) {
138c131
<   private:
---
> private:
140,150c133,141
<     class Freelist
<     {
<       private:
<         T list[orders + 1]{nullptr};
< 
<       public:
< 		void init()
< 		{
< 			for (int i = 0; i < orders + 1; i++)
< 				list[i] = nullptr;
< 		}
---
>     class Freelist {
>     private:
>         T list[orders + 1]{ nullptr };
> 
>     public:
>         void init() {
>             for (int i = 0; i < orders + 1; i++)
>                 list[i] = nullptr;
>         }
152,153c143
<         void add(const T &block, Order order)
<         {
---
>         void add(const T &block, Order order) {
158,160c148,149
<             memset((void *)block, 0, 4096);
< 
<             if (block)
---
>             if (block) {
>                 memset((void *)block, 0, PAGE_SIZE);
162c151
< 
---
>             }
166,167c155
<         T remove(Order order)
<         {
---
>         T remove(Order order) {
181,182c169
<         T next(const T &block) const
<         {
---
>         T next(const T &block) const {
186,187c173
<         bool find(const T &block, Order order) const
<         {
---
>         bool find(const T &block, Order order) const {
189,190c175
<             while (element != nullptr && element != block)
<             {
---
>             while (element != nullptr && element != block) {
198,199c183
<     inline AddressType buddy_of(AddressType block, Order order)
<     {
---
>     inline AddressType buddy_of(AddressType block, Order order) {
203,204c187
<     void coalesce(AddressType block, Order order)
<     {
---
>     void coalesce(AddressType block, Order order) {
222,223c205
<         if (is_buddy_free)
<         {
---
>         if (is_buddy_free) {
225c207
<             coalesce(min(block, buddy), order + 1); // std::min ensures that the smaller block of memory is merged with a larger and not vice-versa (which wouldn't work)
---
>             coalesce(std::min(block, buddy), order + 1);  // std::min ensures that the smaller block of memory is merged with a larger and not vice-versa (which wouldn't work)
233c215
<   private:
---
> private:
238,239c220
< class BuddyManager
< {
---
> class BuddyManager {
241,246c222
<     using Index = int;
< 
<   public:
<     void init(struct limine_memmap_response *memmap_response)
<     {
<         highest_address = memmap_response->entries[memmap_response->entry_count - 1]->base + memmap_response->entries[memmap_response->entry_count - 1]->length;
---
>     using Index = uint64_t;
248,249c224,226
<         // for (int i = 0; i < 100; i++)
<         //     put_pixel(i, 30, 0xffffff);
---
> public:
>     void init(struct stivale2_struct_tag_memmap *memmap_response) {
>         highest_address = memmap_response->memmap[memmap_response->entries - 1].base + memmap_response->memmap[memmap_response->entries - 1].length;
251,252c228,229
<         sort(move(memmap_response));
<         auto num_buddies = reserve_buddy_allocator_memory(move(memmap_response));
---
>         sort(memmap_response);
>         auto num_buddies = reserve_buddy_allocator_memory(memmap_response);
255,257d231
<         // for (int i = 0; i < 100; i++)
<         //     put_pixel(i, 40, 0xffffff);
< 
260,263c234,236
<         for (Index i = 0; i < memmap_response->entry_count; i++)
<         {
<             auto &e = memmap_response->entries[i];
<             if (e->type != LIMINE_MEMMAP_USABLE || e->length <= 4096)
---
>         for (Index i = 0; i < memmap_response->entries; i++) {
>             auto *e = &memmap_response->memmap[i];
>             if (e->type != STIVALE2_MMAP_USABLE || e->length <= PAGE_SIZE)
266,269c239,240
<             for (uint64_t j = 0; j < 64; j++)
<             {
<                 if (e->length & (1ll << j))
<                 {
---
>             for (uint64_t j = 0; j < 64; j++) {
>                 if (e->length & (1ll << j)) {
272d242
<                     trace(TRACE_BUDDY, "[%d] BuddyAllocator managing: 0x%lx-0x%lx [%ld]", idx, e->base, top, (1ll << j));
282,283c252
<         for (Index i = 0; i < idx; i++)
<         {
---
>         for (Index i = 0; i < idx; i++) {
288,289c257
<                 for (Index j = i + 1; j < idx; j++)
<                 {
---
>                 for (Index j = i + 1; j < idx; j++) {
293c261
<                         swap(current, original);
---
>                         std::swap(current, original);
298,300c266
<         trace(TRACE_BUDDY, "Managing a grand total of: %ld bytes", total);
<         // for (int i = 0; i < 100; i++)
<         //     put_pixel(i, 50, 0xFFFFFF);
---
>         firefly::kernel::info_logger << firefly::kernel::info_logger.format("Managing a grand total of: %d bytes\n", total);
305c271,273
<     uint64_t get_highest_address() const { return highest_address; }
---
>     uint64_t get_highest_address() const {
>         return highest_address;
>     }
307,309c275,276
<     AddressType must_alloc(uint64_t size)
<     {
<         auto ptr = this->alloc(size);
---
>     AddressType must_alloc(uint64_t size, FillMode fill = FillMode::NONE) {
>         auto ptr = this->alloc(size, fill);
311c278
<             panic("[Caller: 0x%lx] must_alloc failed to allocate memory!", __builtin_return_address(0));
---
>             firefly::panic("must_alloc failed to allocate memory!");
316,317c283
<     AddressType alloc(uint64_t size)
<     {
---
>     AddressType alloc(uint64_t size, FillMode fill = FillMode::NONE) {
321,326c287,292
<         // Buddy allocators are sorted from largest to smallest order
<         for (Index i = min_idx; i > 0; i--)
<         {
<             auto ptr = buddies[i].alloc(size);
<             if (ptr.unpack())
<             {
---
>         // Buddy allocators are sorted from the largest to smallest order
>         for (Index i = min_idx; i > 0; i--) {
>             // Perform the allocation
>             auto ptr = buddies[i].alloc(size, fill);
> 
>             if (ptr.unpack()) {
331,332c297
<                 for (int j = 0; j < npages; j++, base += 4096)
<                 {
---
>                 for (int j = 0; j < npages; j++, base += PAGE_SIZE) {
346,347c311
<     void free(AddressType ptr)
<     {
---
>     void free(AddressType ptr) {
353a318,322
>         if (page->refcount == 0) {
>             firefly::kernel::info_logger << "Caught potential double-free: " << firefly::kernel::info_logger.hex(ptr) << firefly::kernel::logger::endl;
>             return;
>         }
> 
357a327
> 
359c329
<         auto npages = (1 << (page->order + 3)) / 4096;
---
>         uint32_t npages = (1 << (page->order + 3)) / PAGE_SIZE;
362,363c332
<         for (auto i = 0; i < npages; i++, base += 4096)
<         {
---
>         for (uint32_t i = 0; i < npages; i++, base += PAGE_SIZE) {
372c341
<   private:
---
> private:
374,375c343
<     INLINE void sort(struct limine_memmap_response *mmap)
<     {
---
>     inline void sort(stivale2_struct_tag_memmap *mmap) {
377,378c345
<         for (int i = 0; i < mmap->entry_count; i++)
<         {
---
>         for (uint64_t i = 0; i < mmap->entries; i++) {
381c348
<                 auto &original = mmap->entries[i];
---
>                 auto *original = &mmap->memmap[i];
383,385c350,351
<                 for (int j = i + 1; j < mmap->entry_count; j++)
<                 {
<                     auto &current = mmap->entries[j];
---
>                 for (uint64_t j = i + 1; j < mmap->entries; j++) {
>                     auto *current = &mmap->memmap[j];
387c353
<                         swap(current, original);
---
>                         std::swap(current, original);
393,394c359
<     INLINE uint64_t buddies_required(struct limine_memmap_response *mmap)
<     {
---
>     inline uint64_t buddies_required(stivale2_struct_tag_memmap *mmap) {
396,399c361,363
<         for (Index i = 0; i < mmap->entry_count; i++)
<         {
<             const auto &e = mmap->entries[i];
<             if (e->type != LIMINE_MEMMAP_USABLE || e->length <= 4096)
---
>         for (Index i = 0; i < mmap->entries; i++) {
>             const auto *e = &mmap->memmap[i];
>             if (e->type != STIVALE2_MMAP_USABLE || e->length <= PAGE_SIZE)
411,418c375,380
<     INLINE uint64_t reserve_buddy_allocator_memory(struct limine_memmap_response *mmap)
<     {
<         const auto size = buddies_required(move(mmap)) * sizeof(BuddyAllocator);
< 
<         for (Index i = 0; i < mmap->entry_count; i++)
<         {
<             auto &e = mmap->entries[i];
<             if (e->type != LIMINE_MEMMAP_USABLE || e->length < size)
---
>     inline uint64_t reserve_buddy_allocator_memory(stivale2_struct_tag_memmap *mmap) {
>         const auto size = buddies_required(mmap) * sizeof(BuddyAllocator);
> 
>         for (Index i = 0; i < mmap->entries; i++) {
>             auto *e = &mmap->memmap[i];
>             if (e->type != STIVALE2_MMAP_USABLE || e->length < size)
421c383
<             trace(TRACE_BUDDY, "Creating %ld large hole at region [0x%lx-0x%lx]", size, e->base, e->base + e->length);
---
>             firefly::kernel::info_logger << firefly::kernel::info_logger.format("Creating %d large hole at region [0x%x-0x%x]\n", size, e->base, e->base + e->length);
423,424c385,387
<             e->base = ALIGN_UP(e->base + size);
<             e->length -= ALIGN_DOWN(size);
---
> 
>             e->base = firefly::libkern::align_up4k(e->base + size);
>             e->length -= firefly::libkern::align_down4k(size);
429c392
<         UNREACHABLE;
---
>         __builtin_unreachable();
432,433c395
<     INLINE Index suitable_buddy(uint64_t suitable_order)
<     {
---
>     inline Index suitable_buddy(uint64_t suitable_order) {
435,436c397
<         for (Index i = 0; i < top_idx; i++)
<         {
---
>         for (Index i = 0; i < top_idx; i++) {
440,441c401
<                 for (int j = i + 1; j < top_idx; j++)
<                 {
---
>                 for (Index j = i + 1; j < top_idx; j++) {
444c404
<                     if (current.max_order < original.max_order && current.max_order >= suitable_order)
---
>                     if (current.max_order < original.max_order && current.max_order >= static_cast<BuddyAllocator::Order>(suitable_order))
452c412
<   private:
---
> private:
458c418,419
< EXPOSE_SINGLETON(BuddyManager, buddy);
---
> // Instance created in primary_phys.cpp
> extern BuddyManager buddy;
\ No newline at end of file
